// Code generated by capnpc-go. DO NOT EDIT.

package capnp

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
)

type CIStr capnp.Struct

// CIStr_TypeID is the unique identifier for the type CIStr.
const CIStr_TypeID = 0xb470ed2e0461e004

func NewCIStr(s *capnp.Segment) (CIStr, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return CIStr(st), err
}

func NewRootCIStr(s *capnp.Segment) (CIStr, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return CIStr(st), err
}

func ReadRootCIStr(msg *capnp.Message) (CIStr, error) {
	root, err := msg.Root()
	return CIStr(root.Struct()), err
}

func (s CIStr) String() string {
	str, _ := text.Marshal(0xb470ed2e0461e004, capnp.Struct(s))
	return str
}

func (s CIStr) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (CIStr) DecodeFromPtr(p capnp.Ptr) CIStr {
	return CIStr(capnp.Struct{}.DecodeFromPtr(p))
}

func (s CIStr) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s CIStr) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s CIStr) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s CIStr) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s CIStr) O() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s CIStr) HasO() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s CIStr) OBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s CIStr) SetO(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s CIStr) L() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s CIStr) HasL() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s CIStr) LBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s CIStr) SetL(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

// CIStr_List is a list of CIStr.
type CIStr_List = capnp.StructList[CIStr]

// NewCIStr creates a new list of CIStr.
func NewCIStr_List(s *capnp.Segment, sz int32) (CIStr_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[CIStr](l), err
}

// CIStr_Future is a wrapper for a CIStr promised by a client call.
type CIStr_Future struct{ *capnp.Future }

func (p CIStr_Future) Struct() (CIStr, error) {
	s, err := p.Future.Struct()
	return CIStr(s), err
}

type ColumnInfo capnp.Struct

// ColumnInfo_TypeID is the unique identifier for the type ColumnInfo.
const ColumnInfo_TypeID = 0x9833def99a797b60

func NewColumnInfo(s *capnp.Segment) (ColumnInfo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 5})
	return ColumnInfo(st), err
}

func NewRootColumnInfo(s *capnp.Segment) (ColumnInfo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 5})
	return ColumnInfo(st), err
}

func ReadRootColumnInfo(msg *capnp.Message) (ColumnInfo, error) {
	root, err := msg.Root()
	return ColumnInfo(root.Struct()), err
}

func (s ColumnInfo) String() string {
	str, _ := text.Marshal(0x9833def99a797b60, capnp.Struct(s))
	return str
}

func (s ColumnInfo) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (ColumnInfo) DecodeFromPtr(p capnp.Ptr) ColumnInfo {
	return ColumnInfo(capnp.Struct{}.DecodeFromPtr(p))
}

func (s ColumnInfo) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s ColumnInfo) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s ColumnInfo) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s ColumnInfo) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s ColumnInfo) Id() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s ColumnInfo) SetId(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s ColumnInfo) Name() (CIStr, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return CIStr(p.Struct()), err
}

func (s ColumnInfo) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s ColumnInfo) SetName(v CIStr) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewName sets the name field to a newly
// allocated CIStr struct, preferring placement in s's segment.
func (s ColumnInfo) NewName() (CIStr, error) {
	ss, err := NewCIStr(capnp.Struct(s).Segment())
	if err != nil {
		return CIStr{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s ColumnInfo) Offset() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s ColumnInfo) SetOffset(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

func (s ColumnInfo) OriginDefaultValue() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s ColumnInfo) HasOriginDefaultValue() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s ColumnInfo) OriginDefaultValueBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s ColumnInfo) SetOriginDefaultValue(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s ColumnInfo) OriginDefaultValueBit() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return []byte(p.Data()), err
}

func (s ColumnInfo) HasOriginDefaultValueBit() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s ColumnInfo) SetOriginDefaultValueBit(v []byte) error {
	return capnp.Struct(s).SetData(2, v)
}

func (s ColumnInfo) DefaultIsExpr() bool {
	return capnp.Struct(s).Bit(128)
}

func (s ColumnInfo) SetDefaultIsExpr(v bool) {
	capnp.Struct(s).SetBit(128, v)
}

func (s ColumnInfo) GeneratedExprString() (string, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.Text(), err
}

func (s ColumnInfo) HasGeneratedExprString() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s ColumnInfo) GeneratedExprStringBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.TextBytes(), err
}

func (s ColumnInfo) SetGeneratedExprString(v string) error {
	return capnp.Struct(s).SetText(3, v)
}

func (s ColumnInfo) Dependences() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return capnp.TextList(p.List()), err
}

func (s ColumnInfo) HasDependences() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s ColumnInfo) SetDependences(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(4, v.ToPtr())
}

// NewDependences sets the dependences field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s ColumnInfo) NewDependences(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(4, l.ToPtr())
	return l, err
}

// ColumnInfo_List is a list of ColumnInfo.
type ColumnInfo_List = capnp.StructList[ColumnInfo]

// NewColumnInfo creates a new list of ColumnInfo.
func NewColumnInfo_List(s *capnp.Segment, sz int32) (ColumnInfo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 5}, sz)
	return capnp.StructList[ColumnInfo](l), err
}

// ColumnInfo_Future is a wrapper for a ColumnInfo promised by a client call.
type ColumnInfo_Future struct{ *capnp.Future }

func (p ColumnInfo_Future) Struct() (ColumnInfo, error) {
	s, err := p.Future.Struct()
	return ColumnInfo(s), err
}

func (p ColumnInfo_Future) Name() CIStr_Future {
	return CIStr_Future{Future: p.Future.Field(0, nil)}
}

const schema_85d3acc39d94e0f8 = "x\xdat\x91\xbfk\x14A\x1c\xc5\xdf\xfb\xcen6\xc2" +
	"]\xbc1\x0b\x8aM,R\xa8\x90\xc4\xa0U\x9a\x88?" +
	"\x8a\xeb29\xb0v\xbd\x9d;\x16\xf6f\x97\xbd=T" +
	"ll\xfc\x0f,$`cm%\xfe\x07\x166\x16\xfe" +
	"\x04\x05\x95k\x85\xa4\x10\x8c\xe4\x84\xb0\xb2\x07\x17-\xb4" +
	"{|\xdec\x86\x99O\xeb\xe7eo\xbdyR \xe6" +
	"\x94?W\xdd\xbcwwg\xf2\xf5\xe2#\x98\x90\xaa:" +
	"\x18?|\xfc\xe2\xe9\xbb\x07\xf0\xfd\x00\xd0\xdf\x7f\xe9\xc3" +
	"\x00X\x9f\xbc$Xy\xe3\xc8[\xdd\xcb\x9fC\x87\xfc" +
	"k)\x01\xb0\xb8'o\x17'\xd3\xb4/\xb7\xb1R\x0d" +
	"\xb2\xd8\xa6k\xddHr\x97\xafE\xab\xdd(w\xf9\xc6" +
	"\xd5,\x1dm\x0e\\\xdb\xf5\xb2-\xd2\x9cQ\x1e\xe0\x11" +
	"\xd0oN\x03\xe6\x95\xa2\xf9($C\xd6\xec\xc3y\xc0" +
	"\xbcV4\x9f\x85Z\x18R\x00\xfdi\x030\xef\x15\xcd" +
	"X\xa8\x15C*@\x7f\xd9\x01\xccX\xd1\xec\x0a\xb5'" +
	"!=@\x7f{\x06\x98]Es \xd4\xfe\xfd\x90>" +
	"\xa0\xf7\x0b\xc0\xfcP\xdc\xa6P\xcf\xa9\x90s\x80>|" +
	"\x02lS\xb1\xd3\xa8i\xe0\x85\xac\x9fq\x8c\xb7\x80\xce" +
	"|\xcd\x97)TIL\x1fB\x1f<\xee\xa2\x81e\xeb" +
	"\xcfw\x80l\x81\x9bY\xaf7\xb4\xe5lUeE\xd2" +
	"O\xdc5\xcb^4J\xcb\x1bQ\xaaF\x96\x0d\x08\x1b" +
	"\xff*\x97F\xf6JR\xb2\x09a\x13\xacb;-\xda" +
	"X\x1a^\xbf\x93\x17$\x84\xb5\x82\xbeu\xb6\x88J\xcb" +
	"\xb8\xc6\x9d\xb2\x08\x12\xd7?:5\xb6\xb9u\xb1u\x08" +
	"\xbav\xc8\x05pKqZ.\x80\xff1\xd2\xee\x94," +
	"j\x19\xf3G2\xce\x9d\x00\xcc\xb2\xa2\xb9 \xd43\x1b" +
	"+5<\xabh.\x09\x99\xcdnd:K\xbf\x03\x00" +
	"\x00\xff\xff\xff\x91\x8c\xa4"

func init() {
	schemas.Register(schema_85d3acc39d94e0f8,
		0x9833def99a797b60,
		0xb470ed2e0461e004)
}
